/* GephiEdgeTable.cpp

Description:
This script generates a Gephi edge table from an amino acid sequence file. It does so by 
calculating an adjacency matrix of all the sequences in a simulation. See Thesis - July - 
Final.docx for more details on this definition. A copy can be found at 
/home/rpagan/Download/Thesis @ Assembler or at the link 
http://repositorio.upr.edu:8080/jspui/bitstream/10586%20/564/1/Thesis%20-%20July%20-%20Final.pdf. 
A great source for networks is also Network Science by Barabasi: http://barabasi.com/networksciencebook/.

The adjacency matrix gets generated by comparing all sequences in the "AASEQS" file and outputting a "1"
if there is a Hamming distance exactly equal to "1" between the 2 sequences being considered, otherwise,
"0" is output. 
EXAMPLE: For the sequences A = RFVK, B = RFVV, and C = RFTT, a comparison between A and B would yield "1",
and a comparison between A and C or B and C will yield "0".

Created by Rafael Pagan, rpagan30@gmail.com.

MIT Licenses

Copyright(c) 2017 Rafael Pagan, Steven Massey, & Julian Velev.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files(the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions :

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

USAGE:
1) Place script in the same folder as the desired "AASEQS".
2) Compile it and run: $ g++ GephiEdgeTable.cpp -o Edges
					   $ ./Edges
3) A .csv file gets generated with all of the possible connections between AA 
   sequences that are exactly 1 Hamming distance appart from each other in the AA network.
*/
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <math.h>
#include <algorithm>
#include <set>

using namespace std ;

int main()
{
    remove("adjacencymatrixTEST2.csv") ;
    
    ifstream file ;
    ifstream dna ;
    ofstream matrix ;
    ofstream progress ;
    vector <string> indna ;
    vector <string> dnalist ;
    vector <double> SeqVec ;
    vector <double> distances ;
    string v1, v2 ;

    string dnastring = "" ;
    vector <string>  POPN ; //Population in vector form

    double NewValue =  0 ;
    double D2 = 0 ; //delta^2
    string line ;

    file.open("AASEQS") ;
    progress.open("progress") ;
    matrix.open("adjacencymatrix1EGLNoDrift.csv") ;
    
    //Get unique members from file

    set<string> s;
    while( file >> line )
    {
            cout << line << endl ;
            
	    s.insert(line) ;
            
            line = "" ;
    }
    POPN.assign( s.begin(), s.end() );

    cout<<"POPN size:" << POPN.size() << endl ; 
    cout<<"POPN member length:" << POPN[1].length() << endl ;

    //Checks adjecency of members of population. If an aa string "i" is 1 Hamming distance away from aa string "j", 
    //then a 1 gets added to the matrix element Aij.
	for( int i = 0 ; i < POPN.size() ; i++)
	{
		v1 = POPN[i] ;
		progress << "i: " << i << ". " << "total calculations: " << POPN.size()  << ". " << endl ;

		for( int j = 0 ; j <  POPN.size() ; j++ )
		{	
			if(i<j)
			{
				D2 = 0 ;

				v2 = "" ;

				v2 = POPN[j] ;
			
				int l=0;

               			while( l < v2.length() && D2 < 2 )
                		{		
					if(v1.substr( l , 1 ) != v2.substr( l , 1 ))    
					{ D2++ ; }
                     			l++;
               			}
				if (D2 == 1 ) 
				{ 
					matrix << "S" << i << ";" << "S" << j << endl;
				}
			}

		}
		v1 = "" ;	
	}
	file.close() ;
	matrix.close() ;

	return 0 ;
}
